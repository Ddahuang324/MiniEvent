# 实现计划: 项目全面测试方案（非压力测试）

**分支**: `001-` | **日期**: 2025-09-11 | **规格**: `specs/001-/spec.md`
**输入**: 来自 `/specs/001-/spec.md` 的功能规格

## 执行流程 (/plan 命令范围)
```
1. 加载功能规格 → 成功
2. 填写技术背景 (提取规格中的组件与未知项)
3. 初始章程检查 (记录简单性/测试/可观察性)
4. 阶段 0: 研究 → 解析澄清项并形成 research.md
5. 阶段 1: 设计 → data-model.md, contracts/, quickstart.md
6. 设计后章程复检 → 确认无多余复杂度
7. 描述阶段 2 任务生成策略 (不创建 tasks.md)
8. 更新进度追踪
9. 输出所需工件路径
10. 准备进入 /tasks
```

## 摘要
本计划针对事件驱动网络库 MiniEvent 制定非压力的全面测试体系，实现模块级 + 集成 + 冒烟的验证闭环。重点覆盖 HTTP/TCP 服务行为、事件循环与 IO 多路复用封装、Buffer/Channel/连接与超时管理、配置解析与日志。目标是在 <10 分钟内完成回归，排除性能极限测试。研究阶段将解决规格中剩余的澄清问题并固化假设；设计阶段生成数据模型抽象、契约 (以测试矩阵/脚本接口为主) 与快速使用指引。

## 技术背景
**语言/版本**: C++17 (由 CMakeLists 与源码推断)  
**主要依赖**: 标准库 + 平台系统调用 (select/kqueue)  
**存储**: 不适用 (无持久化，仅内存结构)  
**测试**: 现有测试使用可能是自定义/简单 main + 未来补充 (建议集成 GoogleTest 或 Catch2)  
**目标平台**: macOS (首要), 可扩展到 Linux  
**项目类型**: 单一 (事件驱动网络库 + 示例服务器 + 测试)  
**性能目标**: 非压力；只需功能正确与资源无泄漏  
**约束**: 单次回归 < 10 分钟；CPU 空闲轮询低占用；无长时间阻塞  
**规模/范围**: 模块数量 ~10；用例预计 60-80 条 (单位 + 组件 + 冒烟)  

## 章程检查
**简单性**:
- 项目数量: 1 (src + tests) ✅
- 直接使用框架: 是，无额外抽象层 ✅
- 单一数据模型: 是，内部结构直接使用 ✅
- 避免设计模式: 当前无过度模式 ✅

**架构**:
- 所有内容作为库 + 可执行示例 ✅ (libMiniEvent.a + server demos)
- 计划库: libMiniEvent (核心); tests 不单独成库 ✅
- CLI: 提供冒烟脚本包装即可 (启动 + curl) ✅
- llms.txt: 可选，暂不需要 ❌ (可延后)

**测试 (不可协商)**:
- 采用增量：先补单元/组件测试再冒烟 ✅
- 将引入缺失的断言与负面用例 ✅
- 顺序：模块最小验证 → 组件交互 → 网络 E2E ✅
- 使用真实系统调用 (不 mock) ✅
- 现有测试需要重构分类 ❌ (待阶段 2 任务)

**可观察性**:
- 结构化日志：需要定义统一格式 ❌
- 错误上下文：需扩展失败输出 ❌

**版本控制**:
- 临时功能分支: 001- ✅
- 版本号策略: 尚未定义 ❌ (不在本功能强制范围)

> 初始需改进项: 日志格式定义、测试目录分层、research 解决澄清项。

## 项目结构
沿用现有 `src/` + `tests/`，新增测试分类子目录：
```
tests/
  unit/          # 细粒度：Buffer, Channel, Configure 解析等
  component/     # EventBase + Multiplexer + Connection 管理交互
  integration/   # HTTP/TCP 端到端协议交互
  smoke/         # 快速启动+请求验证 (<5s)
  fixtures/      # 测试辅助文件 (示例配置等)
```
(重定位由阶段 2 任务执行，当前仅规划)

**结构决策**: 保持选项 1 (单一项目)。

## 阶段 0: 大纲与研究
澄清目标 → 形成具体数值/策略基线。

| 未知项 | 研究/决策点 | 期望输出格式 |
|--------|-------------|--------------|
| 外网验证方式 | 是否使用本机端口映射 vs 临时云主机 | Decision + Reason |
| HTTP 错误策略 | 畸形行 / 未知方法 / 超长头 | 表：情况→响应/行为 |
| 头/Buffer 上限 | 合理默认值与拒绝策略 | 数值 + 行为 (扩容/关闭) |
| 必需配置字段 | 解析结构与错误形式 | 字段列表 + 错误消息模式 |
| 日志格式 | 时间戳格式 / 级别集合 / 输出模板 | <timestamp> <level> <component> - msg |
| CPU 阈值 | 空闲占用可接受标准 | 百分比范围 + 测量方法 |
| CI 方案 | 是否已有 (GitHub Actions?) | 是否需要新 workflow 描述 |

research.md 将包含：
- 决策, 理由, 备选方案 (若存在)
- 不再存在 [需要澄清]

## 阶段 1: 设计与契约
输出：
1. data-model.md: 抽象实体字段 (TestEnvironment, Component, TestCase, Scenario, Assumption, CoverageMatrix 条目结构)。
2. contracts/: 定义测试矩阵 (YAML/Markdown) + 冒烟脚本接口约定 (命令行参数: --host --port --timeout)。
3. quickstart.md: “构建→运行冒烟→运行全部测试→生成覆盖矩阵” 步骤。
4. 定义日志格式与配置字段规范 (附在 data-model 或单独段落)。
5. 失败测试先行策略：为缺失模块测试放置占位用例 (EXPECT_FALSE(true) 说明原因)。

## 阶段 2: 任务规划方法 (描述，不执行)
任务生成逻辑：
- 每个 FR → 至少 1 个测试任务 + 1 个实现/补强任务(若需要)
- 研究决策 → 建立基线文件 (如 logging_format.md 若需要)
- 矩阵生成脚本任务 (统计覆盖: 模块 × 测试层级)
- 冒烟脚本任务 (bash: 启动 → 健康检测 → 请求 → 验证 → 退出)
排序：研究基线 → 日志/配置规范 → 基础单元测试 → 组件 → 集成 → 冒烟 → 覆盖脚本 → 清理分类 → CI 接入。
并行标记 [P]: 各独立模块单元测试 (Buffer, Configure, MiniEventLog)。

## 阶段 3+: 未来实现
超出本计划（执行时参考 tasks.md）。

## 复杂度追踪
(当前无需要特别 justify 的架构复杂度)

## 进度追踪
**阶段状态**:
- [x] 阶段 0: 研究完成 (/plan 命令)   # 规划中视为准备执行
- [ ] 阶段 1: 设计完成 (/plan 命令)
- [ ] 阶段 2: 任务规划完成 (/plan 命令 - 仅方法)
- [ ] 阶段 3: 任务已生成 (/tasks 命令)
- [ ] 阶段 4: 实现完成
- [ ] 阶段 5: 验证通过

**门禁状态**:
- [ ] 初始章程检查: 通过
- [ ] 设计后章程检查: 通过
- [ ] 所有 需要澄清 的问题已解决
- [ ] 复杂度偏差已记录

---
*基于章程 v2.1.1*
